1. Öröklődés 
    Hasonló osztályok kezelése: pl ugyanolyan mezők/metódusok 
    ↳ redundancia elkerülése a cél → itt jön be az öröklődés
    <br>
    Azt tudjuk vele elérni, hogy több osztályban megjelennek xyz mezők/metódusok, kódismétlés nélkül. 
    Modellezési/implementációs eszköz 
    <br>
    Van egy ős osztály, aminek a leszármazottjai megöröklik a tuljadonságait. 
    ```
    class Allat {
        GPS hely;
        int suly;

        public void Eszik() {}
        public void Iszik() {}
        public void Mozog(GPS hely) {}
    }

    class Kutya : Allat {
        Ember gazda;

        public void Vadaszik(Allat allat) {}
        public void Pitizik() {}
    }
    ```
    A `Kutya` osztály tartalmazza az `Allat` osztály változóit és metódusait, KIVÉVE a konstruktort és destruktort. 
    A közvetlen és a közvetett őseitől is örököl a leszármazott osztály. 
    Felül lehet írni az örökölt metódusokat. 
    ↳ Az eredeti metódusokat meg lehet hívni 
    <br>
    Protected láthatósági szint: adott osztályban és az összes leszármazottjában elérhető. 
    Statikus dolgok nem öröklődnek. 
2. Polimorfizmus
    hát erről nem volt szó

Korai kötés: compile időben dől el hogy mi fog futni 
Késői kötés: futásidőben dől el hogy mi fog futni 
virtuális metódusok, vtable 

absztrakt osztály: deklarált mezők, de nincsenek implementálva