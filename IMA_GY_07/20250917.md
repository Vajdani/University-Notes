# 6.
**c)**
```
231,139(10) = 11100111(2)
 |   |
 ˇ   ->139
231
```

```
231|1
115|1
 57|1
 28|0
 14|0
  7|1
  3|1
  1|1
  0
```

```
0,139 * 2 = 0,278   0
0,278 * 2 = 0,556   0
0,556 * 2 = 1,112   1
0,112 * 2 = 0,224   0
0,224 * 2 = 0,448   0
0,448 * 2 = 0,896   0
0,896 * 2 = 1,792   1
0,792 * 2 = 1,584   1
0,584 * 2 = 1,168   1
0,168 * 2 = 0,336   0
... (végtelen tizedes tört)
```

- Negatív számok 16 biten(egész számábrázolás - komplemens)
- IEEE756 32 biten (lebegőpontos - normalizálás)

# 7. Negatív számok 16 biten
-25(10) = 11100111(2) 8 bit

negatív - első bit 1
pozitív - első bit 0

```
25|1
12|0
 6|0
 3|1
 1|1
 0
```

csak 5 bit -> hozzáadunk még 3 0 bitet

00011001 -> 11100111
1. invertálás(egyes komplemens) - 11100110
2. +1(kettes komplemens) - 11100111

**Felbontás**  
1|1100111  
a    b  
a - előjel  
b - szám, 2^7 a max tárolás(7 bit) - 128

64 + 32 + 4 + 2 + 1 = 103  
szám - max_tárolás = valódi_szám  
103 - 128 = -25
<br>
-19182(10) = 1011010100010010(2) 16 biten

```
19182|0
 9591|1
 4795|1
 2397|1
 1198|0
  599|1
  299|1
  149|1
   74|0
   37|1
   18|0
    9|1
    4|0
    2|0
    1|1
    0
```
100101011101110 -> **0**100101011101110
1. egyes komplemens - 1011010100010001
2. kettes komplemens - 1011010100010010

ell:  
1|011010100010010  
011010100010010 = 13586  
13586 - 32768 = -19182


# 8. IEEE756 32 biten
10,5(10) = (2) 32 biten

előjel                  - 1 bit  
kitevő/karakterisztika  - 8 bit     jel: K  
mantissa                - 23 bit    jel: m  

N(10) = m * A^k  
A - számrendszer alapja(pl: 10)

```
10(10) = 1010(2)
10|0
 5|1
 2|0
 1|1
 0
```

```
0,5 * 2 = 1
0
```

10,5(10) = 1010.1(2)

1. normalizálás(addig mozgatjuk a vesszőt, ameddig 1,valami nem lesz) - 1.0101 * 2^3 (3-szor mozdítottuk a vesszőt)
2. 
   előjel - 0(pozitív szám)  
   kitevő - k + 127 = 3 + 127 = 130 -> 10000010
   ```
   130|0
    65|1
    32|0
    16|0
     8|0
     4|0
     2|0
     1|1
     0
   ```
   manti. - 0101, feltöltés nullákkal -> 01010000000000000000000

**Végeredmény:** 0|10000010|01010000000000000000000


1338,3125(10) = (2) 32 biten

```
1338|0
 669|1
 334|0
 167|1
  83|1
  41|1
  20|0
  10|0
   5|1
   2|0
   1|1
   0

10100111010
```

```
0,3125 * 2 = 0,625  0
0,625  * 2 = 1,25   1
0,25   * 2 = 0,5    0
0,5    * 2 = 1      1
0

0101
```

10100111010.0101  
normalizálás -> 1.01001110100101 * 2^10

**Végeredmény:** 0|10001001|01001110100101+000000000

10 + 137 = 137
```
137|1
 68|0
 34|0
 17|1
  8|0
  4|0
  2|0
  1|1
  0

10001001
```


# IEEE756 32 biten -> tizes számrendszer 
1|10000101|110110101+00000000000000

10000101(2) = (10)  
128 + 4 + 1 = 133  
133 - 127 = 6 = k

110110101 -> 1.110110101  
1.110110101 * 2^6 -> (denormalizáció) 1110110.101

1110110(2) = 118(10)  
2 + 4 + 16 + 32 + 64 = 118

101 =   
2^-1 + 2^-3 = 0,625

**Végeredmény:** -118,625


# Számelmélet
# 1
**a)**  
89784  
43645
```
89784|2
44892|2
22446|2
11223|3
 3741|3
 1247|29
   43|43
    1|
```
```
43645|5
 8729|7
 1247|29
   43|43
    1|
```

LNKO = 29 * 43 = 1247  
LKKT = 2^3 * 3^2 * 5 * 7 * 29 * 43 = 3142440

LNKO -> Euklideszi algoritmus  
LNKO(360; 225)
```
360 = 225 * 1 + 135
225 = 135 * 1 + 90
135 = 90  * 1 + 45
90  = 45  * 2 + 0

LNKO = 45
```

LNKO(345, 150)
```
345 = 150 * 2 + 45
150 = 45  * 3 + 15
45  = 15  * 3 + 0

LNKO = 15
```

# 2. Hány pozitív osztója van egy számnak?
16 = 5 pozitív osztó
```
16|2
 8|2
 4|2
 2|2
 1
2^4
4 + 1
```

2400 = 36 pozitív osztó
```
2400|2
1200|2
 600|2
 300|2
 150|2
  75|5
  15|5
   3|3
   1
2^5 * 5^2 * 3
(5 + 1) * (2 + 1) * (1 + 1) = 36
```

# 3. Kongruencia
Def: a és b % m, akkor kongruens egymással, ha m|a-b, és ekkor m számot kongruencia modulusnak nevezzük.  
Jel: a === b (három vízszintes vonal) (mod)

Példa:  
**1)**  
1367 === 1581 (mod 10)  
10|1367 - 1581  
10|-214 -> nem kongruens

Tétel: a és b csak akkor kongruens % m, ha ugyanazt a maradékot adják m-mel osztva

**2)**  
1367 = 136 * 10 + 7  
1581 = 158 * 10 + 1  
nem kongruens


-14 === 46 (mod 10)  
10|-14 - 46  
10|-60  
kongruens


2x === 6 (mod 10)  
(nyuszi kettőt ugrik egy 10 állomásos pályán)  
**1)**  
6  === 6 (mod 10)  
16 === 6 (mod 10)  
26 ===  
36 ===  
46 ===

x = {3; 8; 13; 18; ...}

nyuszi visszafelé lép  
2 * -2 -> -4 === 6 (mod 10)  
10|-4 - 6  
10|10

x = {...; -7; -2; 3; 8; 13; 18; ...}
